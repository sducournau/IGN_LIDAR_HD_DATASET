---
# 🇫🇷 Traduisez les champs title et description ci-dessous
sidebar_position: 7
title: Version 1.6.2
description: Dual Installation Support (CPU & GPU)
---sidebar_position: 1
title: v1.6.2 Release Notes
---

<!-- 
🇫🇷 TRADUCTION FRANÇAISE REQUISE
Ce document doit être traduit de l'anglais vers le français.
Veuillez traduire les titres, descriptions et texte principal.
Conservez tous les blocs de code, commandes et exemples techniques tels quels.
-->


# v1.6.2 - Geometric Features Quality & GPU Consistency

**Release Date**: October 3, 2025  
**Type**: Bug Fix & Quality Improvement Release

---

## 🎯 Overview

Version 1.6.2 fixes **critical issues** in geometric feature computation that affected GPU users and improves overall feature quality and robustness. This release ensures consistency between CPU and GPU implementations and adds comprehensive validation.

:::warning Breaking Change for GPU Users
If you previously used GPU acceleration (`use_gpu=True`), feature values have changed. The old GPU formulas were mathematically incorrect. You'll need to retrain models or switch to CPU for compatibility.
:::

---

## 🔧 Critical Fixes

### 1. GPU Feature Formula Correction

**Problem**: GPU implementation used incorrect eigenvalue normalization

- GPU divided by λ₀ (largest eigenvalue) ❌
- CPU divided by Σλ (sum of eigenvalues) ✅ CORRECT
- Result: GPU features incompatible with CPU features

**Fix**:

- Corrected GPU formulas to match standard [Weinmann et al. (2015)](https://www.sciencedirect.com/science/article/pii/S0924271615001842) definitions
- GPU and CPU now produce identical results
- Validated: max relative difference < 0.0001%

**Impact**:

- ✅ GPU/CPU consistency achieved
- ⚠️ **Breaking change**: GPU feature values changed
- Users with GPU-trained models should retrain or switch to CPU

```python
# BEFORE (WRONG)
planarity = (λ1 - λ2) / λ0

# AFTER (CORRECT - matches Weinmann et al.)
planarity = (λ1 - λ2) / (λ0 + λ1 + λ2)
```

---

### 2. Degenerate Case Handling

**Problem**: Points with insufficient neighbors or near-zero eigenvalues produced NaN/Inf

- Collinear points → NaN in geometric features
- Points with < 3 neighbors → Inf values
- Pipeline crashes in downstream processing

**Fix**:

- Added comprehensive validation after eigenvalue computation
- Invalid features set to 0.0 (distinguishable from valid low values)
- Checks for degenerate eigenvalues, NaN, and Inf

**Impact**:

- ✅ No more NaN/Inf propagation
- ✅ Predictable behavior on edge cases
- ✅ No pipeline crashes

```python
# Validation added
valid_features = (
    (eigenvalues[:, 0] >= 1e-6) &  # Non-degenerate
    (eigenvalues[:, 2] >= 1e-8) &  # Non-zero
    ~np.isnan(linearity) &         # No NaN
    ~np.isinf(linearity)           # No Inf
)

# Set invalid to zero
planarity[~valid_features] = 0.0
```

---

### 3. Robust Curvature Computation

**Problem**: Standard deviation sensitive to outliers (common in LIDAR)

- Single outlier point distorts entire neighborhood curvature
- Planar surfaces reported as curved due to noise

**Fix**:

- Replaced `std` with Median Absolute Deviation (MAD)
- `MAD * 1.4826` scaling maintains std-equivalent ranges
- Robust to 50% outliers (median breakdown point)

**Impact**:

- ✅ Better curvature quality on noisy data
- ✅ True surface captured, not noise
- ✅ Similar value ranges (backward compatible)

```python
# BEFORE (outlier-sensitive)
curvature = np.std(distances_along_normal, axis=1)

# AFTER (robust)
median_dist = np.median(distances_along_normal, axis=1, keepdims=True)
mad = np.median(np.abs(distances_along_normal - median_dist), axis=1)
curvature = (mad * 1.4826).astype(np.float32)
```

---

## 🎯 Enhancements

### 4. GPU Radius Search Support

**Added**: Radius-based neighbor search for GPU

- Avoids LIDAR scan line artifacts ("dashed line" patterns)
- Falls back to CPU when radius requested (GPU native impl future work)
- Clear warning messages to users

**Benefit**: Better feature quality by using spatial radius instead of k-NN

```python
# Now supported (with CPU fallback)
geo_features = gpu_computer.extract_geometric_features(
    points, normals, k=20, radius=1.0  # 1m radius
)
```

---

## ✅ Validation

### New Test Suite

Added comprehensive validation: `tests/test_feature_fixes.py`

**Tests**:

1. ✅ GPU/CPU consistency (all features match within 1e-6)
2. ✅ Degenerate case handling (no NaN/Inf)
3. ✅ Robust curvature (outlier resistance)
4. ✅ Feature value ranges (all in [0, 1])

**All tests PASSED** 🎉

---

## 📊 Performance

**No regression observed**:

| Metric            | Before    | After     | Change     |
| ----------------- | --------- | --------- | ---------- |
| CPU throughput    | 10K pts/s | 10K pts/s | None       |
| GPU throughput    | 50K pts/s | 50K pts/s | None       |
| Degenerate filter | N/A       | +0.1ms    | Negligible |
| Robust curvature  | std       | median    | ~Same      |

---

## 🚀 Migration Guide

### For CPU Users

✅ **Minimal impact** - seamless upgrade:

```bash
pip install --upgrade ign-lidar-hd
```

Changes:

- Curvature slightly different (more robust, similar range)
- Degenerate cases now 0.0 instead of NaN (better)
- Existing models should work fine

### For GPU Users

⚠️ **Feature values changed** - action required:

```bash
pip install --upgrade ign-lidar-hd
```

**Option A: Retrain models** (recommended)

```python
# Reprocess your data with fixed GPU features
processor = LiDARProcessor(use_gpu=True)
processor.process_directory('data/raw', 'data/patches_v1.6.2')
# Train new models on updated features
```

**Option B: Switch to CPU** (for old model compatibility)

```python
# Use CPU to maintain compatibility
processor = LiDARProcessor(use_gpu=False)
```

---

## 📚 Documentation

### New Documents

Repository root contains detailed analysis:

1. **GEOMETRIC_FEATURES_ANALYSIS.md** - Comprehensive artifact analysis
2. **FEATURE_FIXES_PROPOSAL.md** - Technical fix specifications
3. **IMPLEMENTATION_SUMMARY.md** - Implementation details
4. **BEFORE_AFTER_COMPARISON.md** - Side-by-side comparison
5. **GEOMETRIC_FEATURES_README.md** - Quick reference

---

## 🔍 Technical Details

### Eigenvalue Normalization

**Standard formulation** ([Weinmann et al., 2015](https://www.sciencedirect.com/science/article/pii/S0924271615001842)):

```
Linearity = (λ₀ - λ₁) / (λ₀ + λ₁ + λ₂)
Planarity = (λ₁ - λ₂) / (λ₀ + λ₁ + λ₂)
Sphericity = λ₂ / (λ₀ + λ₁ + λ₂)
```

Where λ₀ ≥ λ₁ ≥ λ₂ are eigenvalues in descending order.

**Why this matters**:

- Ensures features sum to λ₀/Σλ ≈ constant
- [0, 1] range with meaningful interpretation
- Standard in point cloud literature

### Median Absolute Deviation (MAD)

**Formula**: `MAD = median(|x - median(x)|) * 1.4826`

**Properties**:

- Robust to 50% outliers
- 1.4826 scaling matches std for Gaussian data
- Better for LIDAR (outliers common)

---

## 📖 References

- Weinmann, M., et al. (2015). "Semantic point cloud interpretation based on optimal neighborhoods, relevant features and efficient classifiers." _ISPRS Journal of Photogrammetry and Remote Sensing_, 105, 286-304.
- Demantké, J., et al. (2011). "Dimensionality based scale selection in 3D lidar point clouds."

---

## ✅ What's Next

1. ✅ Upgrade to v1.6.2
2. ✅ Run validation tests: `python tests/test_feature_fixes.py`
3. ⏳ Process test tile and verify output
4. ⏳ Retrain models (GPU users)
5. ⏳ Deploy to production

---

## 📞 Support

**Need help?**

- 📚 Documentation: Full analysis in repository root
- 🧪 Validation: Run `python tests/test_feature_fixes.py`
- 💬 GitHub Issues: Report problems with test results
- 🌐 Website: [https://sducournau.github.io/IGN_LIDAR_HD_DATASET/](https://sducournau.github.io/IGN_LIDAR_HD_DATASET/)
