---
sidebar_position: 1
title: Notes de Version v1.6.2
---

# v1.6.2 - Qualit√© des Caract√©ristiques G√©om√©triques & Coh√©rence GPU

**Date de Sortie** : 3 octobre 2025  
**Type** : Correction de Bugs & Am√©lioration de la Qualit√©

---

## üéØ Aper√ßu

La version 1.6.2 corrige des **probl√®mes critiques** dans le calcul des caract√©ristiques g√©om√©triques qui affectaient les utilisateurs GPU et am√©liore la qualit√© et la robustesse globales des caract√©ristiques. Cette version garantit la coh√©rence entre les impl√©mentations CPU et GPU et ajoute une validation compl√®te.

:::warning Changement Breaking pour les Utilisateurs GPU
Si vous avez pr√©c√©demment utilis√© l'acc√©l√©ration GPU (`use_gpu=True`), les valeurs de caract√©ristiques ont chang√©. Les anciennes formules GPU √©taient math√©matiquement incorrectes. Vous devrez r√©entra√Æner les mod√®les ou passer au CPU pour la compatibilit√©.
:::

---

## üîß Corrections Critiques

### 1. Correction des Formules de Caract√©ristiques GPU

**Probl√®me** : L'impl√©mentation GPU utilisait une normalisation incorrecte des valeurs propres

- Le GPU divisait par Œª‚ÇÄ (plus grande valeur propre) ‚ùå
- Le CPU divisait par Œ£Œª (somme des valeurs propres) ‚úÖ CORRECT
- R√©sultat : Les caract√©ristiques GPU incompatibles avec les caract√©ristiques CPU

**Correction** :

- Correction des formules GPU pour correspondre aux d√©finitions standard de [Weinmann et al. (2015)](https://www.sciencedirect.com/science/article/pii/S0924271615001842)
- GPU et CPU produisent maintenant des r√©sultats identiques
- Valid√© : diff√©rence relative max < 0,0001%

**Impact** :

- ‚úÖ Coh√©rence GPU/CPU atteinte
- ‚ö†Ô∏è **Changement breaking** : Les valeurs de caract√©ristiques GPU ont chang√©
- Les utilisateurs avec des mod√®les entra√Æn√©s sur GPU doivent r√©entra√Æner ou passer au CPU

```python
# AVANT (INCORRECT)
planarity = (Œª1 - Œª2) / Œª0

# APR√àS (CORRECT - correspond √† Weinmann et al.)
planarity = (Œª1 - Œª2) / (Œª0 + Œª1 + Œª2)
```

---

### 2. Gestion des Cas D√©g√©n√©r√©s

**Probl√®me** : Les points avec des voisins insuffisants ou des valeurs propres proches de z√©ro produisaient NaN/Inf

- Points colin√©aires ‚Üí NaN dans les caract√©ristiques g√©om√©triques
- Points avec < 3 voisins ‚Üí valeurs Inf
- Plantages du pipeline dans le traitement en aval

**Correction** :

- Ajout d'une validation compl√®te apr√®s le calcul des valeurs propres
- Les caract√©ristiques invalides sont d√©finies √† 0,0 (distinguables des valeurs faibles valides)
- V√©rifications des valeurs propres d√©g√©n√©r√©es, NaN et Inf

**Impact** :

- ‚úÖ Plus de propagation de NaN/Inf
- ‚úÖ Comportement pr√©visible sur les cas limites
- ‚úÖ Pas de plantages du pipeline

```python
# Validation ajout√©e
valid_features = (
    (eigenvalues[:, 0] >= 1e-6) &  # Non d√©g√©n√©r√©
    (eigenvalues[:, 2] >= 1e-8) &  # Non nul
    ~np.isnan(linearity) &         # Pas de NaN
    ~np.isinf(linearity)           # Pas d'Inf
)

# D√©finir invalide √† z√©ro
planarity[~valid_features] = 0.0
```

---

### 3. Calcul de Courbure Robuste

**Probl√®me** : L'√©cart-type est sensible aux valeurs aberrantes (fr√©quent dans le LiDAR)

- Un seul point aberrant d√©forme toute la courbure du voisinage
- Les surfaces planes sont rapport√©es comme courbes en raison du bruit

**Correction** :

- Remplacement de `std` par la D√©viation Absolue M√©diane (MAD)
- La mise √† l'√©chelle `MAD * 1.4826` maintient des plages √©quivalentes √† std
- Robuste √† 50% de valeurs aberrantes (point de rupture m√©dian)

**Impact** :

- ‚úÖ Meilleure qualit√© de courbure sur donn√©es bruit√©es
- ‚úÖ Surface r√©elle captur√©e, pas le bruit
- ‚úÖ Plages de valeurs similaires (r√©tro-compatible)

```python
# AVANT (sensible aux valeurs aberrantes)
curvature = np.std(distances_along_normal, axis=1)

# APR√àS (robuste)
median_dist = np.median(distances_along_normal, axis=1, keepdims=True)
mad = np.median(np.abs(distances_along_normal - median_dist), axis=1)
curvature = (mad * 1.4826).astype(np.float32)
```

---

## üéØ Am√©liorations

### 4. Support de Recherche par Rayon GPU

**Ajout** : Recherche de voisins bas√©e sur le rayon pour GPU

- √âvite les artefacts de ligne de balayage LiDAR (motifs "lignes pointill√©es")
- Repli sur CPU lorsque le rayon est demand√© (impl√©mentation native GPU pour travaux futurs)
- Messages d'avertissement clairs aux utilisateurs

**Avantage** : Meilleure qualit√© de caract√©ristiques en utilisant un rayon spatial au lieu de k-NN

```python
# Maintenant support√© (avec repli CPU)
geo_features = gpu_computer.extract_geometric_features(
    points, normals, k=20, radius=1.0  # rayon 1m
)
```

---

## ‚úÖ Validation

### Nouvelle Suite de Tests

Ajout d'une validation compl√®te : `tests/test_feature_fixes.py`

**Tests** :

1. ‚úÖ Coh√©rence GPU/CPU (toutes les caract√©ristiques correspondent √† 1e-6 pr√®s)
2. ‚úÖ Gestion des cas d√©g√©n√©r√©s (pas de NaN/Inf)
3. ‚úÖ Courbure robuste (r√©sistance aux valeurs aberrantes)
4. ‚úÖ Plages de valeurs de caract√©ristiques (toutes dans [0, 1])

**Tous les tests R√âUSSIS** üéâ

---

## üìä Performance

**Aucune r√©gression observ√©e** :

| M√©trique         | Avant     | Apr√®s     | Changement  |
| ---------------- | --------- | --------- | ----------- |
| D√©bit CPU        | 10K pts/s | 10K pts/s | Aucun       |
| D√©bit GPU        | 50K pts/s | 50K pts/s | Aucun       |
| Filtre d√©g√©n√©r√©  | N/A       | +0,1ms    | N√©gligeable |
| Courbure robuste | std       | m√©diane   | ~Identique  |

---

## üöÄ Guide de Migration

### Pour les Utilisateurs CPU

‚úÖ **Impact minimal** - mise √† niveau transparente :

```bash
pip install --upgrade ign-lidar-hd
```

Changements :

- Courbure l√©g√®rement diff√©rente (plus robuste, plage similaire)
- Cas d√©g√©n√©r√©s maintenant 0,0 au lieu de NaN (mieux)
- Les mod√®les existants devraient fonctionner correctement

### Pour les Utilisateurs GPU

‚ö†Ô∏è **Valeurs de caract√©ristiques chang√©es** - action requise :

```bash
pip install --upgrade ign-lidar-hd
```

**Option A : R√©entra√Æner les mod√®les** (recommand√©)

```python
# Retraiter vos donn√©es avec les caract√©ristiques GPU corrig√©es
processor = LiDARProcessor(use_gpu=True)
processor.process_directory('data/raw', 'data/patches_v1.6.2')
# Entra√Æner de nouveaux mod√®les sur les caract√©ristiques mises √† jour
```

**Option B : Passer au CPU** (pour compatibilit√© avec anciens mod√®les)

```python
# Utiliser CPU pour maintenir la compatibilit√©
processor = LiDARProcessor(use_gpu=False)
```

---

## üìö Documentation

### Nouveaux Documents

La racine du d√©p√¥t contient une analyse d√©taill√©e :

1. **GEOMETRIC_FEATURES_ANALYSIS.md** - Analyse compl√®te des artefacts
2. **FEATURE_FIXES_PROPOSAL.md** - Sp√©cifications techniques des corrections
3. **IMPLEMENTATION_SUMMARY.md** - D√©tails d'impl√©mentation
4. **BEFORE_AFTER_COMPARISON.md** - Comparaison c√¥te √† c√¥te
5. **GEOMETRIC_FEATURES_README.md** - R√©f√©rence rapide

---

## üîç D√©tails Techniques

### Normalisation des Valeurs Propres

**Formulation standard** ([Weinmann et al., 2015](https://www.sciencedirect.com/science/article/pii/S0924271615001842)) :

```text
Lin√©arit√© = (Œª‚ÇÄ - Œª‚ÇÅ) / (Œª‚ÇÄ + Œª‚ÇÅ + Œª‚ÇÇ)
Planarit√© = (Œª‚ÇÅ - Œª‚ÇÇ) / (Œª‚ÇÄ + Œª‚ÇÅ + Œª‚ÇÇ)
Sph√©ricit√© = Œª‚ÇÇ / (Œª‚ÇÄ + Œª‚ÇÅ + Œª‚ÇÇ)
```

O√π Œª‚ÇÄ ‚â• Œª‚ÇÅ ‚â• Œª‚ÇÇ sont les valeurs propres en ordre d√©croissant.

**Pourquoi c'est important** :

- Garantit que les caract√©ristiques somment √† Œª‚ÇÄ/Œ£Œª ‚âà constante
- Plage [0, 1] avec interpr√©tation significative
- Standard dans la litt√©rature des nuages de points

### D√©viation Absolue M√©diane (MAD)

**Formule** : `MAD = m√©diane(|x - m√©diane(x)|) * 1,4826`

**Propri√©t√©s** :

- Robuste √† 50% de valeurs aberrantes
- La mise √† l'√©chelle 1,4826 correspond √† std pour les donn√©es gaussiennes
- Mieux pour le LiDAR (valeurs aberrantes fr√©quentes)

---

## üìñ R√©f√©rences

- Weinmann, M., et al. (2015). "Semantic point cloud interpretation based on optimal neighborhoods, relevant features and efficient classifiers." _ISPRS Journal of Photogrammetry and Remote Sensing_, 105, 286-304.
- Demantk√©, J., et al. (2011). "Dimensionality based scale selection in 3D lidar point clouds."

---

## ‚úÖ Prochaines √âtapes

1. ‚úÖ Mettre √† niveau vers v1.6.2
2. ‚úÖ Ex√©cuter les tests de validation : `python tests/test_feature_fixes.py`
3. ‚è≥ Traiter une dalle de test et v√©rifier la sortie
4. ‚è≥ R√©entra√Æner les mod√®les (utilisateurs GPU)
5. ‚è≥ D√©ployer en production

---

## üìû Support

**Besoin d'aide ?**

- üìö Documentation : Analyse compl√®te dans la racine du d√©p√¥t
- üß™ Validation : Ex√©cuter `python tests/test_feature_fixes.py`
- üí¨ GitHub Issues : Signaler les probl√®mes avec les r√©sultats des tests
- üåê Site Web : [https://sducournau.github.io/IGN_LIDAR_HD_DATASET/](https://sducournau.github.io/IGN_LIDAR_HD_DATASET/)
