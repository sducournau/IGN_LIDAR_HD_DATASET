---
sidebar_position: 7
title: Version 1.6.2
description: Dual Installation Support (CPU & GPU)
---sidebar_position: 1
title: v1.6.2 Release Notes
---

# v1.6.2 - Geometric Features Quality & GPU Consistency

**Release Date**: October 3, 2025  
**Type**: Bug Fix & Quality Improvement Release

---

## üéØ Overview

Version 1.6.2 fixes **critical issues** in geometric feature computation that affected GPU users and improves overall feature quality and robustness. This release ensures consistency between CPU and GPU implementations and adds comprehensive validation.

:::warning Breaking Change for GPU Users
If you previously used GPU acceleration (`use_gpu=True`), feature values have changed. The old GPU formulas were mathematically incorrect. You'll need to retrain models or switch to CPU for compatibility.
:::

---

## üîß Critical Fixes

### 1. GPU Feature Formula Correction

**Problem**: GPU implementation used incorrect eigenvalue normalization

- GPU divided by Œª‚ÇÄ (largest eigenvalue) ‚ùå
- CPU divided by Œ£Œª (sum of eigenvalues) ‚úÖ CORRECT
- Result: GPU features incompatible with CPU features

**Fix**:

- Corrected GPU formulas to match standard [Weinmann et al. (2015)](https://www.sciencedirect.com/science/article/pii/S0924271615001842) definitions
- GPU and CPU now produce identical results
- Validated: max relative difference < 0.0001%

**Impact**:

- ‚úÖ GPU/CPU consistency achieved
- ‚ö†Ô∏è **Breaking change**: GPU feature values changed
- Users with GPU-trained models should retrain or switch to CPU

```python
# BEFORE (WRONG)
planarity = (Œª1 - Œª2) / Œª0

# AFTER (CORRECT - matches Weinmann et al.)
planarity = (Œª1 - Œª2) / (Œª0 + Œª1 + Œª2)
```

---

### 2. Degenerate Case Handling

**Problem**: Points with insufficient neighbors or near-zero eigenvalues produced NaN/Inf

- Collinear points ‚Üí NaN in geometric features
- Points with < 3 neighbors ‚Üí Inf values
- Pipeline crashes in downstream processing

**Fix**:

- Added comprehensive validation after eigenvalue computation
- Invalid features set to 0.0 (distinguishable from valid low values)
- Checks for degenerate eigenvalues, NaN, and Inf

**Impact**:

- ‚úÖ No more NaN/Inf propagation
- ‚úÖ Predictable behavior on edge cases
- ‚úÖ No pipeline crashes

```python
# Validation added
valid_features = (
    (eigenvalues[:, 0] >= 1e-6) &  # Non-degenerate
    (eigenvalues[:, 2] >= 1e-8) &  # Non-zero
    ~np.isnan(linearity) &         # No NaN
    ~np.isinf(linearity)           # No Inf
)

# Set invalid to zero
planarity[~valid_features] = 0.0
```

---

### 3. Robust Curvature Computation

**Problem**: Standard deviation sensitive to outliers (common in LIDAR)

- Single outlier point distorts entire neighborhood curvature
- Planar surfaces reported as curved due to noise

**Fix**:

- Replaced `std` with Median Absolute Deviation (MAD)
- `MAD * 1.4826` scaling maintains std-equivalent ranges
- Robust to 50% outliers (median breakdown point)

**Impact**:

- ‚úÖ Better curvature quality on noisy data
- ‚úÖ True surface captured, not noise
- ‚úÖ Similar value ranges (backward compatible)

```python
# BEFORE (outlier-sensitive)
curvature = np.std(distances_along_normal, axis=1)

# AFTER (robust)
median_dist = np.median(distances_along_normal, axis=1, keepdims=True)
mad = np.median(np.abs(distances_along_normal - median_dist), axis=1)
curvature = (mad * 1.4826).astype(np.float32)
```

---

## üéØ Enhancements

### 4. GPU Radius Search Support

**Added**: Radius-based neighbor search for GPU

- Avoids LIDAR scan line artifacts ("dashed line" patterns)
- Falls back to CPU when radius requested (GPU native impl future work)
- Clear warning messages to users

**Benefit**: Better feature quality by using spatial radius instead of k-NN

```python
# Now supported (with CPU fallback)
geo_features = gpu_computer.extract_geometric_features(
    points, normals, k=20, radius=1.0  # 1m radius
)
```

---

## ‚úÖ Validation

### New Test Suite

Added comprehensive validation: `tests/test_feature_fixes.py`

**Tests**:

1. ‚úÖ GPU/CPU consistency (all features match within 1e-6)
2. ‚úÖ Degenerate case handling (no NaN/Inf)
3. ‚úÖ Robust curvature (outlier resistance)
4. ‚úÖ Feature value ranges (all in [0, 1])

**All tests PASSED** üéâ

---

## üìä Performance

**No regression observed**:

| Metric            | Before    | After     | Change     |
| ----------------- | --------- | --------- | ---------- |
| CPU throughput    | 10K pts/s | 10K pts/s | None       |
| GPU throughput    | 50K pts/s | 50K pts/s | None       |
| Degenerate filter | N/A       | +0.1ms    | Negligible |
| Robust curvature  | std       | median    | ~Same      |

---

## üöÄ Migration Guide

### For CPU Users

‚úÖ **Minimal impact** - seamless upgrade:

```bash
pip install --upgrade ign-lidar-hd
```

Changes:

- Curvature slightly different (more robust, similar range)
- Degenerate cases now 0.0 instead of NaN (better)
- Existing models should work fine

### For GPU Users

‚ö†Ô∏è **Feature values changed** - action required:

```bash
pip install --upgrade ign-lidar-hd
```

**Option A: Retrain models** (recommended)

```python
# Reprocess your data with fixed GPU features
processor = LiDARProcessor(use_gpu=True)
processor.process_directory('data/raw', 'data/patches_v1.6.2')
# Train new models on updated features
```

**Option B: Switch to CPU** (for old model compatibility)

```python
# Use CPU to maintain compatibility
processor = LiDARProcessor(use_gpu=False)
```

---

## üìö Documentation

### New Documents

Repository root contains detailed analysis:

1. **GEOMETRIC_FEATURES_ANALYSIS.md** - Comprehensive artifact analysis
2. **FEATURE_FIXES_PROPOSAL.md** - Technical fix specifications
3. **IMPLEMENTATION_SUMMARY.md** - Implementation details
4. **BEFORE_AFTER_COMPARISON.md** - Side-by-side comparison
5. **GEOMETRIC_FEATURES_README.md** - Quick reference

---

## üîç Technical Details

### Eigenvalue Normalization

**Standard formulation** ([Weinmann et al., 2015](https://www.sciencedirect.com/science/article/pii/S0924271615001842)):

```
Linearity = (Œª‚ÇÄ - Œª‚ÇÅ) / (Œª‚ÇÄ + Œª‚ÇÅ + Œª‚ÇÇ)
Planarity = (Œª‚ÇÅ - Œª‚ÇÇ) / (Œª‚ÇÄ + Œª‚ÇÅ + Œª‚ÇÇ)
Sphericity = Œª‚ÇÇ / (Œª‚ÇÄ + Œª‚ÇÅ + Œª‚ÇÇ)
```

Where Œª‚ÇÄ ‚â• Œª‚ÇÅ ‚â• Œª‚ÇÇ are eigenvalues in descending order.

**Why this matters**:

- Ensures features sum to Œª‚ÇÄ/Œ£Œª ‚âà constant
- [0, 1] range with meaningful interpretation
- Standard in point cloud literature

### Median Absolute Deviation (MAD)

**Formula**: `MAD = median(|x - median(x)|) * 1.4826`

**Properties**:

- Robust to 50% outliers
- 1.4826 scaling matches std for Gaussian data
- Better for LIDAR (outliers common)

---

## üìñ References

- Weinmann, M., et al. (2015). "Semantic point cloud interpretation based on optimal neighborhoods, relevant features and efficient classifiers." _ISPRS Journal of Photogrammetry and Remote Sensing_, 105, 286-304.
- Demantk√©, J., et al. (2011). "Dimensionality based scale selection in 3D lidar point clouds."

---

## ‚úÖ What's Next

1. ‚úÖ Upgrade to v1.6.2
2. ‚úÖ Run validation tests: `python tests/test_feature_fixes.py`
3. ‚è≥ Process test tile and verify output
4. ‚è≥ Retrain models (GPU users)
5. ‚è≥ Deploy to production

---

## üìû Support

**Need help?**

- üìö Documentation: Full analysis in repository root
- üß™ Validation: Run `python tests/test_feature_fixes.py`
- üí¨ GitHub Issues: Report problems with test results
- üåê Website: [https://sducournau.github.io/IGN_LIDAR_HD_DATASET/](https://sducournau.github.io/IGN_LIDAR_HD_DATASET/)
