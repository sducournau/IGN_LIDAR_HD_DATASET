# ============================================================================
# OPTIMIZED CONFIGURATION FOR HYBRID MODEL TRAINING
# ============================================================================
# Target: PointNet++ Point Segmentation with Intelligent Indexing
# Architecture: Hybrid (supports ensemble models and multi-architecture formats)
# Optimization Focus: Training data quality, augmentation, and FPS sampling
#
# KEY OPTIMIZATIONS:
# - FPS (Farthest Point Sampling) for intelligent point indexing
# - 16K points per patch (PointNet++ standard)
# - 5x augmentation for robust training
# - Normalized features for better convergence
# - Boundary-aware processing with 10m buffer zones
# - GPU-accelerated feature extraction
# ============================================================================

processor:
  lod_level: LOD3
  architecture: hybrid # Hybrid architecture for ensemble models
  use_gpu: true
  num_workers: 1 # Parallel processing for faster training data generation
  patch_size: 150.0 # Optimal for PointNet++ (100-150m patches)
  patch_overlap: 0.1 # 10% overlap for better boundary handling
  num_points: 32768 # Standard for PointNet++ (16K points per patch)
  augment: true # Enable augmentation for robust training
  num_augmentations: 3 # Create 5 augmented versions per patch
  batch_size: 1 # Higher batch size for efficient processing
  prefetch_factor: 1 # Prefetch 1 batch per worker
  pin_memory: true # Enable for faster GPU transfer
features:
  mode: full # Full feature extraction for rich representations
  k_neighbors: 32 # Optimal for PointNet++ (16-32 neighbors)
  include_extra: true # Include geometric features (normals, curvature, planarity)
  use_rgb: false # RGB from orthophotos for semantic understanding
  use_infrared: false # NIR for vegetation/material classification
  compute_ndvi: false # NDVI for enhanced vegetation detection
  sampling_method: fps # FPS (Farthest Point Sampling) for intelligent indexing
  normalize_xyz: true # Normalize coordinates for PointNet++ training
  normalize_features: true # Standardize features (mean=0, std=1) for better convergence
  gpu_batch_size: 1000000 # 1M points per GPU chunk for efficient processing
  use_gpu_chunked: true # GPU chunked processing for large tiles
preprocess:
  enabled: true # Enable preprocessing for cleaner training data
  sor_k: 12 # Statistical Outlier Removal (moderate filtering)
  sor_std: 2.0 # Standard deviation threshold (not too aggressive)
  ror_radius: 0.0 # Disable ROR (SOR is sufficient)
  ror_neighbors: 0
  voxel_enabled: false # Disable voxel downsampling (keep full resolution)
  voxel_size: 0.1 # Not used when voxel_enabled=false
stitching:
  enabled: true # Enable for boundary-aware feature computation
  buffer_size: 10.0 # 10m buffer zone for cross-tile consistency
  auto_detect_neighbors: true # Automatically detect neighboring tiles
  auto_download_neighbors: true # Don't auto-download (manage manually)
  cache_enabled: true # Cache neighboring tile data
output:
  format: npz, laz # NPZ format for efficient ML training (recommended for PointNet++)
  processing_mode: patches_only # Only create ML patches (fastest for training)
  save_stats: true # Save dataset statistics
  save_metadata: true # Save patch metadata for tracking
  compression: null # No compression for faster I/O during training
input_dir: /mnt/c/Users/Simon/ign/enriched_tiles
output_dir: /mnt/c/Users/Simon/ign/patches
